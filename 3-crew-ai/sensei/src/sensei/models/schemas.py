"""Pydantic schemas for Sensei data models.

This module defines all data structures used throughout the application
with Pydantic for validation, serialization, and type safety.
"""

from datetime import datetime
from typing import Any
from uuid import uuid4

from pydantic import BaseModel, Field, field_validator, computed_field

from sensei.models.enums import (
    ConceptStatus,
    ExperienceLevel,
    LearningStyle,
    MessageRole,
    QuestionType,
)


# =============================================================================
# Helper Functions
# =============================================================================

def generate_id(prefix: str = "") -> str:
    """Generate a unique ID with optional prefix.
    
    Args:
        prefix: Optional prefix for the ID (e.g., "course", "module").
    
    Returns:
        A unique string ID like "course-a1b2c3d4".
    """
    short_uuid = str(uuid4())[:8]
    if prefix:
        return f"{prefix}-{short_uuid}"
    return short_uuid


# =============================================================================
# Core Schemas (Subtask 3.2)
# =============================================================================

class Concept(BaseModel):
    """A single concept or topic to learn within a module.
    
    Concepts are the atomic units of learning in Sensei.
    Each concept represents one specific idea or skill to master.
    """
    id: str = Field(default_factory=lambda: generate_id("concept"))
    title: str = Field(..., min_length=1, max_length=200)
    content: str = Field(default="", description="Brief description or learning points")
    order: int = Field(default=0, ge=0, description="Order within the module")
    status: ConceptStatus = Field(default=ConceptStatus.NOT_STARTED)
    mastery: float = Field(default=0.0, ge=0.0, le=1.0, description="Mastery level 0-1")
    questions_asked: int = Field(default=0, ge=0, description="Q&A interactions for this concept")
    
    @field_validator("mastery")
    @classmethod
    def validate_mastery(cls, v: float) -> float:
        """Ensure mastery is between 0 and 1."""
        return max(0.0, min(1.0, v))
    
    def model_dump(self, **kwargs) -> dict[str, Any]:
        """Override to ensure enum values are serialized as strings."""
        data = super().model_dump(**kwargs)
        if "status" in data and isinstance(data["status"], ConceptStatus):
            data["status"] = data["status"].value
        return data


class Module(BaseModel):
    """A chapter or section within a course containing related concepts.
    
    Modules group related concepts together and are followed by
    a quiz to assess understanding.
    """
    id: str = Field(default_factory=lambda: generate_id("module"))
    title: str = Field(..., min_length=1, max_length=200)
    description: str = Field(default="", max_length=1000)
    concepts: list[Concept] = Field(default_factory=list)
    order: int = Field(default=0, ge=0, description="Order within the course")
    estimated_minutes: int = Field(default=30, ge=1, description="Estimated time to complete")
    
    @computed_field
    @property
    def concept_count(self) -> int:
        """Number of concepts in this module."""
        return len(self.concepts)
    
    @computed_field
    @property
    def completed_concepts(self) -> int:
        """Number of completed concepts."""
        return sum(1 for c in self.concepts if c.status == ConceptStatus.COMPLETED)
    
    @computed_field
    @property
    def completion_percentage(self) -> float:
        """Percentage of concepts completed (0-1)."""
        if not self.concepts:
            return 0.0
        return self.completed_concepts / len(self.concepts)
    
    def get_concept(self, concept_idx: int) -> Concept | None:
        """Get a concept by index.
        
        Args:
            concept_idx: Zero-based index of the concept.
        
        Returns:
            The Concept if found, None otherwise.
        """
        if 0 <= concept_idx < len(self.concepts):
            return self.concepts[concept_idx]
        return None


class Course(BaseModel):
    """A complete learning curriculum for a topic.
    
    Courses are generated by the Curriculum Crew and contain
    a structured sequence of modules and concepts.
    """
    id: str = Field(default_factory=lambda: generate_id("course"))
    title: str = Field(..., min_length=1, max_length=200)
    description: str = Field(default="", max_length=2000)
    modules: list[Module] = Field(default_factory=list)
    created_at: datetime = Field(default_factory=datetime.now)
    
    @computed_field
    @property
    def total_modules(self) -> int:
        """Total number of modules."""
        return len(self.modules)
    
    @computed_field
    @property
    def total_concepts(self) -> int:
        """Total number of concepts across all modules."""
        return sum(len(m.concepts) for m in self.modules)
    
    @computed_field
    @property
    def completed_concepts(self) -> int:
        """Total number of completed concepts."""
        return sum(m.completed_concepts for m in self.modules)
    
    @computed_field
    @property
    def completion_percentage(self) -> float:
        """Overall course completion percentage (0-1)."""
        total = self.total_concepts
        if total == 0:
            return 0.0
        return self.completed_concepts / total
    
    @computed_field
    @property
    def estimated_hours(self) -> float:
        """Estimated total hours to complete the course."""
        total_minutes = sum(m.estimated_minutes for m in self.modules)
        return round(total_minutes / 60, 1)
    
    def get_module(self, module_idx: int) -> Module | None:
        """Get a module by index.
        
        Args:
            module_idx: Zero-based index of the module.
        
        Returns:
            The Module if found, None otherwise.
        """
        if 0 <= module_idx < len(self.modules):
            return self.modules[module_idx]
        return None
    
    def get_concept(self, module_idx: int, concept_idx: int) -> Concept | None:
        """Get a concept by module and concept index.
        
        Args:
            module_idx: Zero-based index of the module.
            concept_idx: Zero-based index of the concept.
        
        Returns:
            The Concept if found, None otherwise.
        """
        module = self.get_module(module_idx)
        if module:
            return module.get_concept(concept_idx)
        return None
    
    def model_dump(self, **kwargs) -> dict[str, Any]:
        """Override to ensure datetime is serialized as ISO string."""
        data = super().model_dump(**kwargs)
        if "created_at" in data and isinstance(data["created_at"], datetime):
            data["created_at"] = data["created_at"].isoformat()
        return data


# =============================================================================
# Quiz Schemas (Subtask 3.3)
# =============================================================================

class QuizQuestion(BaseModel):
    """A single quiz question.
    
    Questions are generated by the Assessment Crew and can be
    of various types (multiple choice, true/false, code, open-ended).
    """
    id: str = Field(default_factory=lambda: generate_id("q"))
    question: str = Field(..., min_length=1)
    question_type: QuestionType = Field(default=QuestionType.MULTIPLE_CHOICE)
    options: list[str] = Field(default_factory=list, description="Answer options (for MC/TF)")
    correct_answer: str = Field(..., description="The correct answer")
    explanation: str = Field(default="", description="Explanation of the correct answer")
    concept_id: str = Field(default="", description="Related concept ID")
    difficulty: int = Field(default=1, ge=1, le=5, description="Difficulty 1-5")
    
    @field_validator("options")
    @classmethod
    def validate_options(cls, v: list[str], info) -> list[str]:
        """Validate options based on question type."""
        # Options are required for multiple choice
        return v
    
    def model_dump(self, **kwargs) -> dict[str, Any]:
        """Override to ensure enum values are serialized as strings."""
        data = super().model_dump(**kwargs)
        if "question_type" in data and isinstance(data["question_type"], QuestionType):
            data["question_type"] = data["question_type"].value
        return data


class Quiz(BaseModel):
    """A quiz assessment for a module.
    
    Quizzes are generated after completing a module to assess
    understanding of the concepts covered.
    """
    id: str = Field(default_factory=lambda: generate_id("quiz"))
    module_id: str = Field(..., description="ID of the module being assessed")
    module_title: str = Field(default="", description="Title of the module for display")
    questions: list[QuizQuestion] = Field(default_factory=list)
    created_at: datetime = Field(default_factory=datetime.now)
    
    @computed_field
    @property
    def question_count(self) -> int:
        """Number of questions in the quiz."""
        return len(self.questions)
    
    def get_question(self, question_idx: int) -> QuizQuestion | None:
        """Get a question by index.
        
        Args:
            question_idx: Zero-based index of the question.
        
        Returns:
            The QuizQuestion if found, None otherwise.
        """
        if 0 <= question_idx < len(self.questions):
            return self.questions[question_idx]
        return None
    
    def model_dump(self, **kwargs) -> dict[str, Any]:
        """Override to ensure datetime is serialized as ISO string."""
        data = super().model_dump(**kwargs)
        if "created_at" in data and isinstance(data["created_at"], datetime):
            data["created_at"] = data["created_at"].isoformat()
        return data


class AnswerResult(BaseModel):
    """Result of answering a single quiz question.
    
    Returned after submitting an answer to provide immediate feedback.
    """
    question_id: str = Field(...)
    user_answer: str = Field(...)
    is_correct: bool = Field(...)
    correct_answer: str = Field(...)
    explanation: str = Field(default="")


class QuizResult(BaseModel):
    """Complete results of a quiz attempt.
    
    Generated by the Assessment Crew after evaluating all answers.
    """
    quiz_id: str = Field(...)
    course_id: str = Field(default="")
    module_id: str = Field(default="")
    module_title: str = Field(default="")
    score: float = Field(..., ge=0.0, le=1.0, description="Score as decimal 0-1")
    correct_count: int = Field(..., ge=0)
    total_questions: int = Field(..., ge=0)
    weak_concepts: list[str] = Field(default_factory=list, description="Concept IDs needing review")
    feedback: str = Field(default="", description="AI-generated feedback")
    passed: bool = Field(default=False)
    completed_at: datetime = Field(default_factory=datetime.now)
    
    @field_validator("score")
    @classmethod
    def validate_score(cls, v: float) -> float:
        """Ensure score is between 0 and 1."""
        return max(0.0, min(1.0, v))
    
    @computed_field
    @property
    def score_percentage(self) -> int:
        """Score as an integer percentage 0-100."""
        return int(self.score * 100)
    
    def model_dump(self, **kwargs) -> dict[str, Any]:
        """Override to ensure datetime is serialized as ISO string."""
        data = super().model_dump(**kwargs)
        if "completed_at" in data and isinstance(data["completed_at"], datetime):
            data["completed_at"] = data["completed_at"].isoformat()
        return data


# =============================================================================
# User & Session Schemas (Subtask 3.4)
# =============================================================================

class UserPreferences(BaseModel):
    """User preferences and profile settings.
    
    Stored in user_preferences.json and used to personalize
    the learning experience.
    """
    name: str = Field(default="", max_length=100)
    learning_style: LearningStyle = Field(default=LearningStyle.READING)
    session_length_minutes: int = Field(default=30, ge=5, le=180)
    experience_level: ExperienceLevel = Field(default=ExperienceLevel.BEGINNER)
    goals: str = Field(default="", max_length=1000)
    is_onboarded: bool = Field(default=False)
    
    def model_dump(self, **kwargs) -> dict[str, Any]:
        """Override to ensure enum values are serialized as strings."""
        data = super().model_dump(**kwargs)
        if "learning_style" in data and isinstance(data["learning_style"], LearningStyle):
            data["learning_style"] = data["learning_style"].value
        if "experience_level" in data and isinstance(data["experience_level"], ExperienceLevel):
            data["experience_level"] = data["experience_level"].value
        return data
    
    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "UserPreferences":
        """Create UserPreferences from a dictionary.
        
        Handles string enum values from JSON storage.
        """
        if "learning_style" in data and isinstance(data["learning_style"], str):
            data["learning_style"] = LearningStyle(data["learning_style"])
        if "experience_level" in data and isinstance(data["experience_level"], str):
            data["experience_level"] = ExperienceLevel(data["experience_level"])
        return cls(**data)


class ChatMessage(BaseModel):
    """A single message in the Q&A chat.
    
    Used in the Learning page for Q&A interactions with Sensei.
    """
    role: MessageRole = Field(...)
    content: str = Field(..., min_length=1)
    timestamp: datetime = Field(default_factory=datetime.now)
    
    def model_dump(self, **kwargs) -> dict[str, Any]:
        """Override to ensure proper serialization."""
        data = super().model_dump(**kwargs)
        if "role" in data and isinstance(data["role"], MessageRole):
            data["role"] = data["role"].value
        if "timestamp" in data and isinstance(data["timestamp"], datetime):
            data["timestamp"] = data["timestamp"].isoformat()
        return data
    
    @classmethod
    def user_message(cls, content: str) -> "ChatMessage":
        """Create a user message."""
        return cls(role=MessageRole.USER, content=content)
    
    @classmethod
    def assistant_message(cls, content: str) -> "ChatMessage":
        """Create an assistant message."""
        return cls(role=MessageRole.ASSISTANT, content=content)


class LearningSession(BaseModel):
    """State of an active learning session.
    
    Tracks the user's current position in a course and
    stores chat history for the session.
    """
    id: str = Field(default_factory=lambda: generate_id("session"))
    course_id: str = Field(...)
    current_module_idx: int = Field(default=0, ge=0)
    current_concept_idx: int = Field(default=0, ge=0)
    started_at: datetime = Field(default_factory=datetime.now)
    chat_history: list[ChatMessage] = Field(default_factory=list)
    concepts_covered: int = Field(default=0, ge=0)
    questions_asked: int = Field(default=0, ge=0)
    
    def add_message(self, message: ChatMessage) -> None:
        """Add a message to the chat history."""
        self.chat_history.append(message)
        if message.role == MessageRole.USER:
            self.questions_asked += 1
    
    def advance_concept(self, total_concepts_in_module: int, total_modules: int) -> bool:
        """Advance to the next concept.
        
        Args:
            total_concepts_in_module: Number of concepts in current module.
            total_modules: Total number of modules in the course.
        
        Returns:
            True if advanced, False if at end of course.
        """
        self.concepts_covered += 1
        
        if self.current_concept_idx < total_concepts_in_module - 1:
            # More concepts in this module
            self.current_concept_idx += 1
            return True
        elif self.current_module_idx < total_modules - 1:
            # Move to next module
            self.current_module_idx += 1
            self.current_concept_idx = 0
            return True
        else:
            # End of course
            return False
    
    def go_back_concept(self) -> bool:
        """Go back to the previous concept.
        
        Returns:
            True if went back, False if at start.
        """
        if self.current_concept_idx > 0:
            self.current_concept_idx -= 1
            return True
        elif self.current_module_idx > 0:
            # Would need to know previous module's concept count
            # For now, just go to start of previous module
            self.current_module_idx -= 1
            self.current_concept_idx = 0  # Will be adjusted by caller
            return True
        return False
    
    def model_dump(self, **kwargs) -> dict[str, Any]:
        """Override to ensure datetime is serialized as ISO string."""
        data = super().model_dump(**kwargs)
        if "started_at" in data and isinstance(data["started_at"], datetime):
            data["started_at"] = data["started_at"].isoformat()
        return data


class Progress(BaseModel):
    """Learning progress for a course.
    
    Tracks completion status and time spent learning.
    Stored in the SQLite database.
    """
    course_id: str = Field(...)
    completion_percentage: float = Field(default=0.0, ge=0.0, le=1.0)
    modules_completed: int = Field(default=0, ge=0)
    total_modules: int = Field(default=0, ge=0)
    concepts_completed: int = Field(default=0, ge=0)
    total_concepts: int = Field(default=0, ge=0)
    time_spent_minutes: int = Field(default=0, ge=0)
    current_module_idx: int = Field(default=0, ge=0)
    current_concept_idx: int = Field(default=0, ge=0)
    last_accessed: datetime | None = Field(default=None)
    created_at: datetime = Field(default_factory=datetime.now)
    
    @field_validator("completion_percentage")
    @classmethod
    def validate_completion(cls, v: float) -> float:
        """Ensure completion is between 0 and 1."""
        return max(0.0, min(1.0, v))
    
    @computed_field
    @property
    def completion_display(self) -> str:
        """Completion as a display string like '75%'."""
        return f"{int(self.completion_percentage * 100)}%"
    
    @computed_field
    @property
    def is_complete(self) -> bool:
        """Whether the course is fully completed."""
        return self.completion_percentage >= 1.0
    
    def model_dump(self, **kwargs) -> dict[str, Any]:
        """Override to ensure datetime is serialized as ISO string."""
        data = super().model_dump(**kwargs)
        if "last_accessed" in data and isinstance(data["last_accessed"], datetime):
            data["last_accessed"] = data["last_accessed"].isoformat()
        if "created_at" in data and isinstance(data["created_at"], datetime):
            data["created_at"] = data["created_at"].isoformat()
        return data
    
    @classmethod
    def from_db_row(cls, row: dict[str, Any]) -> "Progress":
        """Create Progress from a database row.
        
        Handles string datetime values from SQLite.
        """
        data = dict(row)
        if "last_accessed" in data and isinstance(data["last_accessed"], str):
            data["last_accessed"] = datetime.fromisoformat(data["last_accessed"])
        if "created_at" in data and isinstance(data["created_at"], str):
            data["created_at"] = datetime.fromisoformat(data["created_at"])
        return cls(**data)


# =============================================================================
# LLM Output Schemas (for CrewAI output_pydantic)
# =============================================================================
# These schemas are used for CrewAI's structured output feature.
# They don't include auto-generated fields like id, created_at, etc.
# After receiving the LLM output, the crew converts these to full models.

class ConceptOutput(BaseModel):
    """LLM output schema for a concept (without auto-generated fields)."""
    title: str = Field(..., description="Concept title")
    content: str = Field(default="", description="Markdown content with overview, key points, misconceptions, applications")
    order: int = Field(default=0, ge=0, description="Order within the module (0-based)")


class ModuleOutput(BaseModel):
    """LLM output schema for a module (without auto-generated fields)."""
    title: str = Field(..., description="Module title")
    description: str = Field(default="", description="Module description with learning objectives")
    order: int = Field(default=0, ge=0, description="Order within the course (0-based)")
    estimated_minutes: int = Field(default=60, ge=1, description="Estimated time (60-240 minutes)")
    concepts: list[ConceptOutput] = Field(default_factory=list, description="3-7 concepts per module")


class CourseOutput(BaseModel):
    """LLM output schema for a course (without auto-generated fields).
    
    Used as output_pydantic for CurriculumCrew's research_content_task.
    """
    title: str = Field(..., description="Course title based on the topic")
    description: str = Field(default="", description="Brief course description (2-3 sentences)")
    modules: list[ModuleOutput] = Field(default_factory=list, description="5-10 ordered learning modules")


class QuizQuestionOutput(BaseModel):
    """LLM output schema for a quiz question (without auto-generated fields)."""
    question: str = Field(..., description="Clear question text")
    question_type: str = Field(
        default="multiple_choice",
        description="One of: multiple_choice, true_false, code, open_ended"
    )
    options: list[str] = Field(default_factory=list, description="Answer options (for MC/TF)")
    correct_answer: str = Field(..., description="The correct answer")
    explanation: str = Field(default="", description="Educational explanation of the correct answer")
    concept_id: str = Field(default="", description="Related concept ID")
    difficulty: int = Field(default=2, ge=1, le=5, description="Difficulty 1-5")


class QuizOutput(BaseModel):
    """LLM output schema for a quiz (without auto-generated fields).
    
    Used as output_pydantic for AssessmentCrew's generate_quiz_task.
    """
    questions: list[QuizQuestionOutput] = Field(
        default_factory=list,
        description="5-8 quiz questions covering module concepts"
    )


class QuizEvaluationOutput(BaseModel):
    """LLM output schema for quiz evaluation.
    
    Used as output_pydantic for AssessmentCrew's evaluate_quiz_task.
    """
    score: float = Field(..., ge=0.0, le=1.0, description="Score as decimal 0-1")
    passed: bool = Field(..., description="Whether the learner passed (80% threshold)")
    correct_count: int = Field(..., ge=0, description="Number of correct answers")
    total_questions: int = Field(..., ge=0, description="Total number of questions")
    weak_concepts: list[str] = Field(default_factory=list, description="Concept IDs needing review")
    feedback: str = Field(default="", description="Encouraging, personalized feedback")
    detailed_analysis: dict[str, Any] = Field(
        default_factory=dict,
        description="Analysis with strengths, areas_for_improvement, patterns_noticed"
    )
    recommendation: str = Field(default="proceed", description="One of: proceed, review")
    next_steps: str = Field(default="", description="What the learner should do next")


# =============================================================================
# Lesson Content Schema (for Teaching Crew output)
# =============================================================================

class ConceptLesson(BaseModel):
    """Generated lesson content for a concept.
    
    Returned by the Teaching Crew when teaching a concept.
    """
    concept_id: str = Field(...)
    concept_title: str = Field(...)
    lesson_content: str = Field(..., description="Markdown lesson content")
    key_takeaways: list[str] = Field(default_factory=list)
    code_examples: list[str] = Field(default_factory=list)
    
    # Context for navigation
    module_title: str = Field(default="")
    module_idx: int = Field(default=0)
    concept_idx: int = Field(default=0)
    total_concepts_in_module: int = Field(default=0)
    
    # Navigation flags
    has_previous: bool = Field(default=False)
    has_next: bool = Field(default=True)
    is_module_complete: bool = Field(default=False)


# =============================================================================
# Summary Statistics Schema
# =============================================================================

class LearningStats(BaseModel):
    """Overall learning statistics across all courses.
    
    Displayed on the Dashboard and Progress pages.
    """
    total_courses: int = Field(default=0, ge=0)
    concepts_mastered: int = Field(default=0, ge=0)
    total_concepts: int = Field(default=0, ge=0)
    hours_learned: float = Field(default=0.0, ge=0.0)
    current_streak: int = Field(default=0, ge=0)
    longest_streak: int = Field(default=0, ge=0)
    
    @computed_field
    @property
    def mastery_percentage(self) -> float:
        """Percentage of concepts mastered (0-1)."""
        if self.total_concepts == 0:
            return 0.0
        return self.concepts_mastered / self.total_concepts
